架构设计的关键思维是**判断和取舍**，程序设计的关键思维是**逻辑和实现**。


# “架构”到底指什么？

问题：

架构和框架是什么关系？有什么区别？

微信有架构，微信的登录系统也有架构，微信的支付系统也有架构，当我们谈微信架构时，到底在谈什么架构？

准确回答以上问题，关键在于梳理**系统、子系统、模块、组件、框架和架构**的概念。


## 系统与子系统

> 系统泛指由一群有**关联**的个体组成，根据某种**规则**运作，能完成个别元件不能单独完成的工作的群体。它的意思是“总体”、“整体”或“联盟”

关联：系统是由一群有关联的个体组成的，没有关联的个体堆在一起不能成为一个系统。例如，把一个发动机和一台PC放在一起不能称之为一个系统，把发动机、底盘、轮胎、车架组合起来才能成为一台汽车。

规则：系统内的个体需要按照指定的规则运作，而不是单个个体各自为政。规则规定了系统内个体分工和协作的方式。例如，汽车发动机负责产生动力，然后通过变速器和传动轴，将动力输出到车轮上，从而驱动汽车前进。

能力：系统能力与个体能力有本质的差别。系统能力不是个体能力之和，而是产生了新的能力。例如，汽车能够载重前进，而发动机、变速器、传动轴，车轮本身都不具备这样的能力。

> 子系统也是由一群有关联的个体所组成的系统，多半是更大系统中的一部分。

以微信为例子：

1) 微信本身是一个系统，包含聊天、登录、朋友圈等子系统

2) 朋友圈这个系统又包含动态、评论、点赞等子系统

3) 评论这个系统可能又包含防刷子系统、审核子系统、发布子系统、存储子系统

4) 评论审核子系统不再包含业务意义上的子系统，而是包含各个模块或组件，这些模块或组件本身也是另外一个维度上的系统。例如，MySQL，Redis等是存储系统，但不是业务子系统。


## 模块与组件

> 模块：软件模块（Module）是一套一致且互相有紧密关联的软件组织，它包含程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。

**模块的接口**表达了由该模块提供的功能和调用它时所需的元素。模块是可能分开被编写的单位，这使得它们可再用，并允许开发人员同时协作、编写及研究不同的模块。

> 组件：软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易地被用于组装应用程序。

模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已。

**从逻辑角度来拆分后得到的单元就是“模块”，从物理角度来拆分系统得到的单元就是“组件”。划分模块的主要目的是职责分离，划分组件的主要目的是单元复用**。


## 框架与架构

> 软件框架（software framework）通常是指为了实现某个业务标准或完成特定的基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。

(1)框架是组件规范。例如，MVC就是一种常见的开发规范，类似的还有 MVP、MVVM、J2EE等框架。

(2)框架提供基础功能的产品。例如，Spring MVC是MVC的开发框架，除了满足MVC的规范，Spring提供了多基础功能来帮助我们实现功能，包括注解、Spring Security、Spring JPA等很多基础功能。

个人理解，前端的框架有目前流行的Vue、React、Angular。Vue 就是典型的 MVVM 框架。Vue 是框架，MVVM是开发规范。

**框架(Framework)关注的是“规范”，架构(Architecture)关注的是“结构”**。

可以从不同的角度，如**业务逻辑、物理部署、开发规范**等不同角度来实现系统的架构。


## 重新定义架构

**软件架构指软件系统的顶层结构**。


## 软件架构的历史

### 机器语言（1940年之前）：

0 1 代码
	
太难写、太难读、太难改

### 汇编语言（20世纪40年代）

又叫符号语言---mov ax,bx
	
程序员需要了解计算机底层知识：如CPU指令、寄存器、段地址
	
不同cpu的汇编指令和结构不同--同一个程序，需要针对不同的cpu编写不同的汇编代码
	
	
本质上还是面向机器的，程序员需要将现实世界中的问题和需求按照机器的逻辑进行翻译。


### 高级语言（20世纪50年代）

不需要关注机器底层的低级结构和逻辑，只需要关注具体的问题和业务。
	
通过编译程序的处理，高级语言可以被编译成适合不同cpu指令的机器语言。程序员只需要写一次程序，可以在不同机器上编译运行。不需要根据不同的机器指令重写整个程序。
	
高级语言----->编译----->机器语言

	
### 第一次软件危机与结构化程序设计（20世纪60-70年代）

由于软件的**“逻辑”**变得非常复杂

导致软件质量低下、项目无法如期完成、项目严重超支-----提出“软件危机”
	
解决方案：
	
提出“软件工程”---一定程度上缓解软件危机
	
提出“**结构化程序设计**”----抛弃goto语句，采取“自顶向下，逐步细化、模块化”的思想----本质是面向过程---只是从整体上降低软件开发复杂度-----一定程度上缓解软件危机
	
	
### 第二次软件危机与面向对象（20世纪80年代）	
	
由于软件的**“扩展”**变得非常复杂
   
结构化程序设计----只能缓解软件“逻辑”的复杂性，对业务变化带来的软件“扩展”无能为力。
   
解决方案：
   
提出“**面向对象**”的开发思想

	
### 软件架构（20世纪90年代）

> 随着软件系统规模的增加，计算相关的算法和数据结构不再构成主要的设计问题。当系统由许多部分组成时，整个系统的组织，也就是所说的“软件架构”，导致一系列新的设计问题。

软件架构相关的问题：

1.系统规模庞大，内部耦合严重，开发效率低，

2.后续修改和扩展困难

3.出问题后很难排查和修复


### 历史总结

结构化编程---提出“模块”

面向对象编程---提出“对象”

软件架构---提出“组件”


模块、对象、组件 本质上都是对到达一定规模的软件进行拆分。


## 软件设计的目的

整个软件技术发展的历史，就是一部与“复杂度”斗争的历史，架构的出现也不例外。

架构就是为了应对软件系统**复杂度**提出的解决方案。

架构设计的主要目的就是：**为了解决复杂度带来的问题**。


## 架构设计常见问题

需求多，不知从哪入手进行架构设计？------找到系统复杂性所在地方，然后针对这些复杂点进行架构设计

架构设计要考虑高性能、高可能、高扩展吗-----架构设计并不是要面面俱到，而是要找到复杂点，然后有针对性的解决问题。

也就是说要**有的放矢**，而不是贪大求全。

**“架构设计是为了解决软件复杂度”**是高屋建瓴的指导原则。


## 软件复杂度来源

### 高性能

* 单机复杂度
	
计算机内部复杂度最关键的地方就是操作系统。

操作系统是软件系统的运行环境，操作系统的复杂度直接决定了软件系统的复杂度。
	
操作系统和性能相关的就是进程和线程。

	
* 多台机器集群复杂度

