架构设计的关键思维是**判断和取舍**，程序设计的关键思维是**逻辑和实现**。


# “架构”到底指什么？

问题：

架构和框架是什么关系？有什么区别？

微信有架构，微信的登录系统也有架构，微信的支付系统也有架构，当我们谈微信架构时，到底在谈什么架构？

准确回答以上问题，关键在于梳理**系统、子系统、模块、组件、框架和架构**的概念。


## 系统与子系统

> 系统泛指由一群有**关联**的个体组成，根据某种**规则**运作，能完成个别元件不能单独完成的工作的群体。它的意思是“总体”、“整体”或“联盟”

关联：系统是由一群有关联的个体组成的，没有关联的个体堆在一起不能成为一个系统。例如，把一个发动机和一台PC放在一起不能称之为一个系统，把发动机、底盘、轮胎、车架组合起来才能成为一台汽车。

规则：系统内的个体需要按照指定的规则运作，而不是单个个体各自为政。规则规定了系统内个体分工和协作的方式。例如，汽车发动机负责产生动力，然后通过变速器和传动轴，将动力输出到车轮上，从而驱动汽车前进。

能力：系统能力与个体能力有本质的差别。系统能力不是个体能力之和，而是产生了新的能力。例如，汽车能够载重前进，而发动机、变速器、传动轴，车轮本身都不具备这样的能力。

> 子系统也是由一群有关联的个体所组成的系统，多半是更大系统中的一部分。

以微信为例子：

1) 微信本身是一个系统，包含聊天、登录、朋友圈等子系统

2) 朋友圈这个系统又包含动态、评论、点赞等子系统

3) 评论这个系统可能又包含防刷子系统、审核子系统、发布子系统、存储子系统

4) 评论审核子系统不再包含业务意义上的子系统，而是包含各个模块或组件，这些模块或组件本身也是另外一个维度上的系统。例如，MySQL，Redis等是存储系统，但不是业务子系统。


## 模块与组件

> 模块：软件模块（Module）是一套一致且互相有紧密关联的软件组织，它包含程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。

**模块的接口**表达了由该模块提供的功能和调用它时所需的元素。模块是可能分开被编写的单位，这使得它们可再用，并允许开发人员同时协作、编写及研究不同的模块。

> 组件：软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易地被用于组装应用程序。

模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已。

**从逻辑角度来拆分后得到的单元就是“模块”，从物理角度来拆分系统得到的单元就是“组件”。划分模块的主要目的是职责分离，划分组件的主要目的是单元复用**。


## 框架与架构

> 软件框架（software framework）通常是指为了实现某个业务标准或完成特定的基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。

(1)框架是组件规范。例如，MVC就是一种常见的开发规范，类似的还有 MVP、MVVM、J2EE等框架。

(2)框架提供基础功能的产品。例如，Spring MVC是MVC的开发框架，除了满足MVC的规范，Spring提供了多基础功能来帮助我们实现功能，包括注解、Spring Security、Spring JPA等很多基础功能。

个人理解，前端的框架有目前流行的Vue、React、Angular。Vue 就是典型的 MVVM 框架。Vue 是框架，MVVM是开发规范。

**框架(Framework)关注的是“规范”，架构(Architecture)关注的是“结构”**。

可以从不同的角度，如**业务逻辑、物理部署、开发规范**等不同角度来实现系统的架构。


## 重新定义架构

**软件架构指软件系统的顶层结构**。


## 软件架构的历史

### 机器语言（1940年之前）：

0 1 代码
	
太难写、太难读、太难改

### 汇编语言（20世纪40年代）

又叫符号语言---mov ax,bx
	
程序员需要了解计算机底层知识：如CPU指令、寄存器、段地址
	
不同cpu的汇编指令和结构不同--同一个程序，需要针对不同的cpu编写不同的汇编代码
	
	
本质上还是面向机器的，程序员需要将现实世界中的问题和需求按照机器的逻辑进行翻译。


### 高级语言（20世纪50年代）

不需要关注机器底层的低级结构和逻辑，只需要关注具体的问题和业务。
	
通过编译程序的处理，高级语言可以被编译成适合不同cpu指令的机器语言。程序员只需要写一次程序，可以在不同机器上编译运行。不需要根据不同的机器指令重写整个程序。
	
高级语言----->编译----->机器语言

	
### 第一次软件危机与结构化程序设计（20世纪60-70年代）

由于软件的**“逻辑”**变得非常复杂

导致软件质量低下、项目无法如期完成、项目严重超支-----提出“软件危机”
	
解决方案：
	
提出“软件工程”---一定程度上缓解软件危机
	
提出“**结构化程序设计**”----抛弃goto语句，采取“自顶向下，逐步细化、模块化”的思想----本质是面向过程---只是从整体上降低软件开发复杂度-----一定程度上缓解软件危机
	
	
### 第二次软件危机与面向对象（20世纪80年代）	
	
由于软件的**“扩展”**变得非常复杂
   
结构化程序设计----只能缓解软件“逻辑”的复杂性，对业务变化带来的软件“扩展”无能为力。
   
解决方案：
   
提出“**面向对象**”的开发思想

	
### 软件架构（20世纪90年代）

> 随着软件系统规模的增加，计算相关的算法和数据结构不再构成主要的设计问题。当系统由许多部分组成时，整个系统的组织，也就是所说的“软件架构”，导致一系列新的设计问题。

软件架构相关的问题：

1.系统规模庞大，内部耦合严重，开发效率低，

2.后续修改和扩展困难

3.出问题后很难排查和修复


### 历史总结

结构化编程---提出“模块”

面向对象编程---提出“对象”

软件架构---提出“组件”


模块、对象、组件 本质上都是对到达一定规模的软件进行拆分。


## 软件设计的目的

整个软件技术发展的历史，就是一部与“复杂度”斗争的历史，架构的出现也不例外。

架构就是为了应对软件系统**复杂度**提出的解决方案。

架构设计的主要目的就是：**为了解决复杂度带来的问题**。


## 架构设计常见问题

需求多，不知从哪入手进行架构设计？------找到系统复杂性所在地方，然后针对这些复杂点进行架构设计

架构设计要考虑高性能、高可能、高扩展吗-----架构设计并不是要面面俱到，而是要找到复杂点，然后有针对性的解决问题。

也就是说要**有的放矢**，而不是贪大求全。

**“架构设计是为了解决软件复杂度”**是高屋建瓴的指导原则。


## 软件复杂度来源

### 高性能

* 单机复杂度
	
计算机内部复杂度最关键的地方就是操作系统。

操作系统是软件系统的运行环境，操作系统的复杂度直接决定了软件系统的复杂度。
	
操作系统和性能相关的就是进程和线程。

	
* 多台机器集群复杂度

系统拆分：任务分配、任务分解

1.任务分配：

指每台机器都能处理完整的业务任务，不同的任务分配到不同的机器上执行。

需要增加任务分配器。

比如，从1台业务服务器，增加到2台业务服务器，由任务分配器进行业务分配。


2.任务分配器：

可能是硬件网络设备，也可能是软件网络设备，也可能是负载均衡软件，还可能是自己开发的系统。

与真正的业务服务器之间有连接和交互。

需要对连接进行管理：比如连接建立、连接检测、连接中断后如何处理等

需要增加分配算法：比如轮询算法、按权重分配、或者按负载分配。

如果按负载分配，则业务服务器还要能够上报自己的状态给任务分配器。


3.按任务分配的方式搭建架构：

“任务”涵盖范围广，可以指完整的业务处理，也可以单指某个具体的任务。

比如“存储”、“运算”、“缓存”都可以作为一项任务。

因此存储系统、运算系统、缓存系统都可以按照任务分配的方式来搭建架构。


4.任务分配器可以是算法：

任务分配器不一定只能是物理上存在的机器或一个独立运行的程序，也可以是嵌入在其他程序中的算法。


5.任务分解：

单纯只通过任务分配的方式来扩展性能，收益会越来越低。

业务服务器如果越来越复杂，可以将其拆分为更多的组成部分。

任务分解：从逻辑上将各个子业务进行拆分。

比如微信：将微信后台拆成接入、注册登录、消息、摇一摇、漂流瓶、其他业务。

简单总结，任务分解就是将原来**大一统但复杂**的业务系统，拆分成**小而简单但需要多个系统配合**的业务系统。


6.任务分解可以提升性能的因素

简单的系统更容易做到高性能、

可以针对单个任务进行扩展、


7.不是任务分解的越细，性能就越高

因为系统间的调用通道目前都是通过网络传输的方式---性能比系统内的函数调用要低很多。


* 总结：

**系统拆分在某种程度上能提升业务处理性能，但最终决定业务处理性能的还是业务逻辑本身**。


### 高可用

高可用，代表系统的可用性程度。无中断能力。

系统的高可用方案五花八门，但万变不离其宗，本质上都是**通过“冗余”来实现高可用**。-----1台机器不够---2台

单纯从形式看，高性能与高可用的“冗余”一样，都是通过增加更多机器来达到目的。

本质区别：

高性能增加机器目的在于“扩展”处理性能

高可用增加机器目的在于“冗余”处理单元


* 计算高可用

“计算”指业务的逻辑处理。

通过增加任务分配器，由1台计算服务器，变成2台或多台计算服务器。


* 存储高可用

**存储高可用的难点不在如何备份数据，而在于如何减少或规避数据不一致对业务造成的影响**。


* 高可用状态决策

无论是计算高可用、还是存储高可用，其基础都是“状态决策”：系统需要能够判断当前的状态是正常/异常

通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确。

1.独裁式

只有1个决策者

决策者：负责收集信息，然后进行决策

上报者：将状态信息发送给决策者

优点：不会出现决策混乱

缺点：当决策者本身故障，整个系统无法实现准确的状态决策

2.协商式

有2个决策者

两个决策者通过交流信息，然后根据规则进行决策。最常用的协商决策---主备决策

主备决策：

2台服务器启动时都是备机--->2台服务器建立连接--->2台服务器交换状态信息---->某1台服务器做出决策，成为主机；另一台服务器继续保持备机身份

难点：如果两者信息交换出现问题，比如主备连接中断，决策怎么做

3.民主式

多个独立的个体通过投票方式进行状态决策：独立的个体之间交换信息，每个个体做出自己的决策，然后按照“多数取胜”的规则确定最终状态。

缺陷：脑裂


* 总结

无论采用什么方案，状态决策都不可能做到任何场景下都没有问题。


### 可扩展性

唯一不变的是变化。

* 预测变化

* 采取方案应对变化


### 低成本

低成本不会是架构设计的首要目标，而是架构设计的附加约束。

### 安全

* 功能安全

功能安全其实就是“防小偷”

与具体编码相关，与架构关系不大

* 架构安全

架构安全就是“防强盗”

比如，传统架构安全主要依靠防火墙


### 规模

规模带来的复杂度的主要原因是“量变引起质变”

1.功能越来越多，导致系统复杂度指数级上升

2.数据越来越多，系统复杂度发生质变

大数据就是在这种背景下产生的。

